
 This document contains all the new annotations, and practices
 I gained over the project.



 // <<<*** Practices I would share with past self to save time and nerves: ***>>> //


 Build custom exceptions to make it easier to handle errors
 to provide more specific reasons for why a database operation failed.


 Create a consistent error response structure (ErrorResponse class)
 to make debugging and frontend integration easier:

 {
   "status": 404,
   "timestamp": "2025-06-05T16:22:11",
   "message": "Product with ID 123 not found"
 }

 This saves time, especially when you're both the backend and frontend dev ( = ^.^=)/



 Handle exception throwing in the service layer, where business logic is executed.
 If a process fails, throw a meaningful exception. This exception will be caught by
 Spring‚Äôs DispatcherServlet, and handled by a bean annotated with @ControllerAdvice,
 which then returns a custom error response to the client.


 ‚ö†Ô∏è Warning:

 Avoid using `BLOB` columns to store large binary data like images, videos, or files.
 Instead, upload them to cloud storage (e.g., Firebase, Supabase, S3) and store only the URL.
 This highly improves database performance and scalability.



 // <<<*** Annotations: ***>>> //

 ** @GeneratedValue(strategy = GenerationType.IDENTITY) **

 It tells the JPA provider (typically Hibernate, when using Spring Data JPA)
 to let the database generate the primary key, usually via an AUTO_INCREMENT column.
 In a Spring Boot application, by default Hibernate ORM is used under the hood, and it implements
 the logic for key generation based on the chosen strategy.

  Strategies:

  With AUTO JPA chooses based on database

  With SEQUENCE, Hibernate can generate the ID before the insert, allowing
  batching, cascading inserts, and more flexibility.
  Supported by Postgres and Oracle, unlike MySQL

  With IDENTITY, Hibernate must wait until after the insert
  to get the ID ‚Üí harder to batch and may affect performance.

  With TABLE Uses a special table to generate IDs (less common now)

  | Strategy         | ID generated by                        | Example setting                        |
  | ---------------- | -------------------------------------- | -------------------------------------- |
  | `IDENTITY`       | ‚úÖ **DBMS**                             | `@GeneratedValue(strategy = IDENTITY)` |
  | `SEQUENCE`       | ‚úÖ **DBMS** (but Hibernate triggers it) | `@GeneratedValue(strategy = SEQUENCE)` |
  | `TABLE`          | ‚ùå **Framework (JPA)**                  | `@GeneratedValue(strategy = TABLE)`    |
  | `AUTO` (default) | Depends on DB & provider               | `@GeneratedValue()`                    |

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "my_seq_gen")
  @SequenceGenerator(name = "my_seq_gen", sequenceName = "my_sequence", allocationSize = 20)
  private Long id;


 üëâ ** @Lob **

 It is JPA annotation, specifies that the field should be persisted as a Large Object, which
 can be either a CLOB (Character Large Object) for String/char[],
 or a BLOB (Binary Large Object) for byte[].


 It‚Äôs a data type used to store binary data such as:
    -   Images (e.g. JPEG, PNG)
    -   Audio/video files (MP3, MP4)
    -   PDFs or any non-text files



 ** Side effects avoid marking BLOB/CLOB as @Lob

 In case you don't explicitly tell the Spring framework that a field
 in your class is a large object ‚Äî such as a description field of type
 String ‚Äî each database will apply its own default mappings. Most commonly,
 such fields are mapped as regular VARCHAR or VARBINARY, which are limited
 in size. For example, VARCHAR(255) is a common default, and in some databases
 this is limited to 4,000 bytes. If data exceeds this limit, it may be truncated,
 potentially damaging a file and losing important content.

 On the other hand, fields annotated with @Lob are mapped in the database
 as CLOB (Character Large Object) or BLOB (Binary Large Object), which can store
 much larger data‚Äîsometimes up to several gigabytes.

 Example:
 CREATE TABLE product (
     id SERIAL PRIMARY KEY,
     name VARCHAR(255),
     description TEXT,       -- CLOB equivalent
     image BYTEA             -- BLOB equivalent in PostgreSQL
 );

 Note:
 In PostgreSQL, TEXT is used for large strings (CLOB), and BYTEA is
 used for binary data (BLOB).


 In summary:
 Use @Lob when you expect large data sizes, such as long text, images, files,
 PDFs, or videos. Without it, Hibernate or any other ORM may default to types
 with size limits, which can silently fail or throw errors during persistence.


   üëâ ** @ControllerAdvice **

  This annotation marks this class as a global exception handler.
  It makes the class a Spring-managed bean that enables centralized
  exception handling across all @Controller classes.
  The DispatcherServlet delegates to this class when exceptions are
  thrown during request processing in any controller.


   üëâ ** @ExceptionHandler **

  This annotation tells Spring that this method handles exceptions the specified type ‚Äî for
  example ProductNotFoundException, FileStorageException. When such an exception is thrown in
  any controller method, and no local handler is found, this method will be invoked to handle
  it, allowing custom response construction.


   // <<<*** Spring properties: ***>>> //

 Some databases, such as PostgreSQL, have known issues when working with Large Objects
 (LOBs) (e.g., CLOB, BLOB, TEXT, BYTEA) if auto-commit is enabled.

 By default, JDBC connections may auto-commit each individual SQL statement.
 However, inserting or updating large objects typically requires multiple steps
 within a single transaction. If auto-commit is enabled, the connection may commit
 prematurely before the LOB operation is fully complete, which can lead to:

    -   SQLException or I/O errors
    -   LOB not being persisted correctly
    -   Unexpected transaction behavior or data corruption



 ‚úÖ Solution:
 To ensure LOB operations are safely handled within a transaction,
 you should disable auto-commit at the connection level. In Spring Boot
 (using HikariCP as the default connection pool),
 this is done in application.properties:

 spring.datasource.hikari.auto-commit=false




 // <<<*** @EnableAutoconfiguration ***>>> //

 When Spring Boot detects @EnableAutoConfiguration, it scans its meta-annotations.
 It sees @Import(AutoConfigurationImportSelector.class) and triggers it.
 Spring creates instance of AutoConfigurationImportSelector and invokes selectImports().
 selectImports() uses AutoConfigurationMetadataLoader to load candidates from spring.factories
 or AutoConfiguration.imports.
 Spring iterates over each candidate configuration class.

 Each configuration is processed with conditional annotations:

 @ConditionalOnClass ‚Üí checks presence of required classes on classpath.

 @ConditionalOnMissingBean ‚Üí checks if a bean already exists.

 @ConditionalOnProperty ‚Üí checks if certain properties are enabled.

 If all conditions are satisfied, configuration class is imported into context.
 Spring parses configuration class ‚Äî detects methods annotated with @Bean.
 If bean doesn't exist, Spring registers the bean definition into context.
 Some configurations rely on @AutoConfigurationPackage to register the package
 of the main application for component scanning.
 Other features like @ConditionalOnWebApplication,
 @ConditionalOnSingleCandidate, @ConditionalOnResource are evaluated similarly during this phase.
 Result: Spring builds an application context that contains only applicable auto-configured beans
 based on classpath, properties, and user-defined beans.


 // <<<*** Spring Rest without MVC Architecture ***>>> //

 You can build backend for the small applications without Spring MVC architecture.

 By adding the Spring Data Rest dependency, Spring automatically exposes your
 JPA repositories as RESTFul endpoint no need manually write controllers.

 This works based on the entities in your model package and the repository layer.
 Once you define a CrudRepository or JpaRepository, Spring Data REST takes care
 of the routing and response handling behind the scenes.

 Additionally, Spring Data REST supports HATEOAS (Hypermedia as the Engine of Application State).
 This means that each response includes special links (like self, product, next, ect.)
 to help clients navigate the API and understand available actions for each resource.

 üìå Use it when:

  - You‚Äôre building a simple CRUD app or a prototype
  - You want minimal boilerplate
  - You don‚Äôt need complex request/response logic



  // <<<*** Spring AOP ***>>> //

  Spring AOP (Aspect Oriented Programming) is a programing paradigm that
  complements OOP by providing a way to modularize cross-cutting concerns.

  Cross-cutting concerns are functionalities that are needed across different
  parts of an application, such as logging, security, and transaction management.

  Instead of scattering all of this concerns throughout the code, Spring AOP
  allows defining them in one place and applying them where needed.

  Key Concepts:

   - Aspect:
    A module that encapsulates a cross-cutting concern (e.g. logging, security, transactions, etc.).
    It's basically a class annotated with @Aspect.

   - Join Point:
    A specific point in the execution of the program, such as a method call,
    object creation, exception handling, etc.

    In Spring AOP, join points are usually method executions.

   - Pointcut:
    A predicate (expression) that matches certain join points where advice should be applied.

    Example:
    execution(* com.example.service.*.*(..)) ‚Äî matches all methods in service package.

   - Weaving:
    The process of linking aspects with other application types to create an advised object.
    In Spring AOP, weaving is done at runtime using dynamic proxies (no bytecode manipulation).

   - Proxy:
    A wrapper object created by Spring that adds the aspect logic (advice) to your actual bean.
    The client interacts with the proxy, not directly with the target object.

   - Advice:
    The action to take at a particular join point (e.g. code to execute before or after a method).
    You write advice methods inside your @Aspect class.

   - Type of Advice:

    | Type                | Meaning                                                    | Annotation        |
    | ------------------- | ---------------------------------------------------------- | ----------------- |
    | **Before**          | Runs *before* the method executes                          | `@Before`         |
    | **After**           | Runs *after* the method completes (success or exception)   | `@After`          |
    | **After Returning** | Runs *after* method completes successfully                 | `@AfterReturning` |
    | **After Throwing**  | Runs *after* method throws an exception                    | `@AfterThrowing`  |
    | **Around**          | Runs *before and after* the method (can control execution) | `@Around`         |



  How Spring AOP Works:

  Spring AOP uses proxies to implement aspects. When a method call is made on a target object,
  Spring intercepts the call and applies the appropriate advice based on the configured pointcuts.
  Spring AOP can use either JDK dynamic proxies (for interfaces) or CGLIB proxies (for classes)
  to create these proxies.

  Example Use Cases:

  Logging: Logging method calls, parameters, and return values.
  Security: Enforcing authentication and authorization checks.
  Transaction Management: Managing database transactions.
  Caching: Implementing caching mechanisms.
  Performance Monitoring: Tracking method execution times.

